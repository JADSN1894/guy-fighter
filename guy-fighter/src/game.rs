use rand::Rng;
use rustyline::DefaultEditor;
use rustyline::error::ReadlineError;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use wasmtime::component::{Component, Linker, bindgen};
use wasmtime::{Engine, Store};

use crate::names;
use crate::visualization;

// Generates bindings for the guy-fighter and guy-fighter-plugin worlds defined in the wit/guy-fighter.wit file.
bindgen!("guy-fighter");
bindgen!("guy-fighter-plugin");

// Generated by the above bindgen macro
pub use tl::guy_fighter::guy_fighter_host::TypeOfGuy;

pub type PluginId = usize;

// Host state that is shared across plugins and the main game loop.
pub struct HostState {
    pub builtin_types_of_guy: Vec<TypeOfGuy>,
    pub invented_types_of_guy: Vec<(PluginId, TypeOfGuy)>,
    pub plugin_descs: HashMap<PluginId, PluginDesc>,
    pub next_plugin_id: PluginId,
    pub executing_plugin_id: Option<PluginId>,
}

pub struct PluginDesc {
    pub name: String,
    pub path: PathBuf,
}

impl PluginDesc {
    pub fn new(name: String, path: PathBuf) -> Self {
        PluginDesc { name, path }
    }
}

pub fn load_plugins(plugins_dir: &Path) -> wasmtime::Result<Store<HostState>> {
    let engine = Engine::default();
    let mut linker = Linker::new(&engine);
    let mut store = Store::new(&engine, HostState::new());
    GuyFighterPlugin::add_to_linker(&mut linker, |state| state)?;

    // Load all the plugins from the specified directory
    if plugins_dir.is_dir() {
        for entry in fs::read_dir(plugins_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() {
                let component = Component::from_file(&engine, &path)?;
                let plugin = GuyFighterPlugin::instantiate(&mut store, &component, &linker)?;

                let plugin_id = store.data().next_plugin_id;
                store.data_mut().next_plugin_id += 1;

                // Call the plugin's init and get its name, setting the executing_plugin_id so that
                // host functions the plugin calls know where the call came from. This is kinda icky;
                // maybe there's a way to bind the plugin's ID to the instance?
                store.data_mut().executing_plugin_id = Some(plugin_id);
                plugin.call_init(&mut store)?;
                let plugin_name = plugin.call_get_plugin_name(&mut store)?;
                store.data_mut().executing_plugin_id = None;

                // Insert the plugin description into the store's state
                store
                    .data_mut()
                    .plugin_descs
                    .insert(plugin_id, PluginDesc::new(plugin_name, path.clone()));
            }
        }
    } else {
        return Err(wasmtime::Error::msg("Plugins directory does not exist"));
    }
    Ok(store)
}

impl TypeOfGuy {
    fn new(name: String, strength: u8, agility: u8, charisma: u8) -> Self {
        TypeOfGuy {
            name,
            strength,
            agility,
            charisma,
        }
    }
}

impl HostState {
    pub fn new() -> Self {
        HostState {
            builtin_types_of_guy: vec![
                TypeOfGuy::new("Guy who's made of nails".to_string(), 18, 0, 0),
                TypeOfGuy::new(
                    "Guy who's made of normal guy stuff, except his hands, which are made of nails"
                        .to_string(),
                    14,
                    6,
                    4,
                ),
            ],
            invented_types_of_guy: vec![],
            plugin_descs: HashMap::new(),
            next_plugin_id: 1,
            executing_plugin_id: None,
        }
    }
}

impl tl::guy_fighter::guy_fighter_host::Host for HostState {
    fn invent_entirely_new_type_of_guy(&mut self, guy_type: TypeOfGuy) -> () {
        // We retrieve the current plugin ID from the state, which tells us which plugin invented this type of guy.
        let plugin_id = self.executing_plugin_id.unwrap_or(0);
        self.invented_types_of_guy.push((plugin_id, guy_type));
    }
}

#[derive(Clone)]
pub struct Guy<'a> {
    pub name: String,
    pub guy_type: &'a TypeOfGuy,
}

impl<'a> Guy<'a> {
    fn new(name: String, guy_type: &'a TypeOfGuy) -> Self {
        Guy { name, guy_type }
    }
}

fn select_random_guy_type(state: &HostState) -> &TypeOfGuy {
    let mut rng = rand::thread_rng();

    // Get total number of guy types
    let builtin_count = state.builtin_types_of_guy.len();
    let invented_count = state.invented_types_of_guy.len();
    let total_count = builtin_count + invented_count;

    // Generate a single random index for all types
    let idx = rng.gen_range(0..total_count);

    if idx < builtin_count {
        // Select from builtin types
        &state.builtin_types_of_guy[idx]
    } else {
        // Select from invented types
        &state.invented_types_of_guy[idx - builtin_count].1
    }
}

fn roll_attribute_contest(attr1: u8, attr2: u8) -> (bool, u32, u32) {
    let mut rng = rand::thread_rng();

    loop {
        let roll1 = rng.gen_range(1..=DICE_SIDES) + attr1 as u32;
        let roll2 = rng.gen_range(1..=DICE_SIDES) + attr2 as u32;

        if roll1 != roll2 {
            return (roll1 > roll2, roll1, roll2);
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ContestType {
    Strength,
    Agility,
    Charisma,
}

const DICE_SIDES: u32 = 20;

fn fight_round(guy1: &Guy, guy2: &Guy, round: u8) -> bool {
    let mut rng = rand::thread_rng();

    // Randomly select which attribute to contest
    let contest_type = rng.gen_range(0..3);
    let (attr1, attr2, contest_type) = match contest_type {
        0 => (
            guy1.guy_type.strength,
            guy2.guy_type.strength,
            ContestType::Strength,
        ),
        1 => (
            guy1.guy_type.agility,
            guy2.guy_type.agility,
            ContestType::Agility,
        ),
        _ => (
            guy1.guy_type.charisma,
            guy2.guy_type.charisma,
            ContestType::Charisma,
        ),
    };

    let (guy1_wins, roll1, roll2) = roll_attribute_contest(attr1, attr2);
    visualization::print_fight_round(round, guy1, guy2, contest_type, attr1, attr2, roll1, roll2);
    guy1_wins
}

fn fight(state: &HostState) {
    // Generate two random fighters
    let guy_type1 = select_random_guy_type(state);
    let guy_type2 = select_random_guy_type(state);

    let guy1 = Guy::new(names::generate_name(), guy_type1);
    let guy2 = Guy::new(names::generate_name(), guy_type2);

    let mut guy1_wins = 0;
    let mut guy2_wins = 0;

    visualization::print_fight_introduction(&guy1, &guy2);

    for round in 1..=3 {
        if fight_round(&guy1, &guy2, round) {
            guy1_wins += 1;
        } else {
            guy2_wins += 1;
        }

        if guy1_wins == 2 {
            visualization::print_winner(&guy1.name);
            return;
        } else if guy2_wins == 2 {
            visualization::print_winner(&guy2.name);
            return;
        }
    }
}

fn main_loop(store: Store<HostState>) -> rustyline::Result<()> {
    visualization::print_header();
    visualization::print_menu();

    let mut rl = DefaultEditor::new()?;
    loop {
        match rl.readline("guy> ") {
            Ok(line) => {
                let command = line.trim().to_lowercase();
                if command.is_empty() {
                    continue; // Skip empty lines
                }
                rl.add_history_entry(&line)?;

                match command.as_str() {
                    "quit" => break,
                    "plugins" => visualization::print_plugins_table(&store),
                    "types" => visualization::print_guy_types(&store),
                    "fight" => fight(store.data()),
                    "help" => visualization::print_menu(),
                    _ => println!("Unknown command: {}", command),
                }
            }
            Err(ReadlineError::Interrupted) | Err(ReadlineError::Eof) => {
                break;
            }
            Err(err) => {
                eprintln!("Error reading line: {:?}", err);
            }
        }
    }
    Ok(())
}

pub fn run_game(plugins_dir: &Path) -> wasmtime::Result<()> {
    let store = load_plugins(plugins_dir)?;

    if let Err(e) = main_loop(store) {
        return Err(wasmtime::Error::msg(format!("Error in main loop: {:?}", e)));
    }
    Ok(())
}
