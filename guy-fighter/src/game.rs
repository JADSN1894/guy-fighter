use rand::Rng;
use rustyline::DefaultEditor;
use rustyline::error::ReadlineError;
use std::cell::RefCell;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use wasmtime::component::{Component, Linker, bindgen};
use wasmtime::{Engine, Store};

use crate::names;
use crate::visualization;

// Generates bindings for the guy-fighter and guy-fighter-plugin worlds defined in the wit/guy-fighter.wit file.
bindgen!("guy-fighter");
bindgen!("guy-fighter-plugin");

// Generated by the above bindgen macro
pub use tl::guy_fighter::guy_fighter_host::TypeOfGuy;

pub type PluginId = usize;

pub struct GameState {
    pub builtin_types_of_guy: Vec<TypeOfGuy>,
    pub invented_types_of_guy: RefCell<Vec<(PluginId, TypeOfGuy)>>,
    pub plugin_descs: HashMap<PluginId, PluginDesc>,
    pub next_plugin_id: PluginId,
}

struct PluginState<'a> {
    plugin_id: PluginId,
    game_state: &'a GameState,
}

impl<'a> PluginState<'a> {
    pub fn new(id: PluginId, state: &'a GameState) -> Self {
        PluginState {
            plugin_id: id,
            game_state: state,
        }
    }
}

pub struct PluginDesc {
    pub name: String,
    pub path: PathBuf,
}

impl PluginDesc {
    pub fn new(name: String, path: PathBuf) -> Self {
        PluginDesc { name, path }
    }
}

pub fn load_plugins(state: &mut GameState, plugins_dir: &Path) -> wasmtime::Result<()> {
    let engine = Engine::default();
    let mut linker = Linker::new(&engine);
    GuyFighterPlugin::add_to_linker(&mut linker, |state| state)?;

    // Load all the plugins from the specified directory
    if plugins_dir.is_dir() {
        for entry in fs::read_dir(plugins_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() {
                let component = Component::from_file(&engine, &path)?;

                let plugin_id = state.next_plugin_id;
                state.next_plugin_id += 1;

                let plugin_name = {
                    let mut store = Store::new(&engine, PluginState::new(plugin_id, &state));
                    let plugin = GuyFighterPlugin::instantiate(&mut store, &component, &linker)?;
                    plugin.call_init(&mut store)?;
                    plugin.call_get_plugin_name(&mut store)?
                };

                // Insert the plugin description into the store's state
                state
                    .plugin_descs
                    .insert(plugin_id, PluginDesc::new(plugin_name, path.clone()));
            }
        }
    } else {
        return Err(wasmtime::Error::msg("Plugins directory does not exist"));
    }
    Ok(())
}

impl TypeOfGuy {
    fn new(name: String, strength: u8, agility: u8, charisma: u8, battle_cries: Vec<String>) -> Self {
        TypeOfGuy {
            name,
            strength,
            agility,
            charisma,
            battle_cries
        }
    }
}

impl GameState {
    pub fn new() -> Self {
        GameState {
            builtin_types_of_guy: vec![
                TypeOfGuy::new("Guy who's made of nails".to_string(), 18, 0, 0, 
            vec!["Nailed it!".to_string()]),
                TypeOfGuy::new(
                    "Guy who's made of normal guy stuff, except his hands, which are made of nails"
                        .to_string(),
                    14,
                    6,
                    4,
                    vec!["Why is life pain?".to_string()],
                ),
            ],
            invented_types_of_guy: RefCell::new(vec![]),
            plugin_descs: HashMap::new(),
            next_plugin_id: 1,
        }
    }
}

impl tl::guy_fighter::guy_fighter_host::Host for PluginState<'_> {
    fn invent_entirely_new_type_of_guy(&mut self, guy_type: TypeOfGuy) -> () {
        // We retrieve the current plugin ID from the state, which tells us which plugin invented this type of guy.
        self.game_state
            .invented_types_of_guy
            .borrow_mut()
            .push((self.plugin_id, guy_type));
    }
}

#[derive(Clone)]
pub struct Guy<'a> {
    pub name: String,
    pub guy_type: &'a TypeOfGuy,
}

impl<'a> Guy<'a> {
    fn new(name: String, guy_type: &'a TypeOfGuy) -> Self {
        Guy { name, guy_type }
    }
}

fn select_random_guy_type(state: &GameState) -> TypeOfGuy {
    let mut rng = rand::thread_rng();

    // Get total number of guy types
    let builtin_count = state.builtin_types_of_guy.len();
    let invented_count = state.invented_types_of_guy.borrow().len();
    let total_count = builtin_count + invented_count;

    // Generate a single random index for all types
    let idx = rng.gen_range(0..total_count);

    if idx < builtin_count {
        // Select from builtin types
        state.builtin_types_of_guy[idx].clone()
    } else {
        // Select from invented types
        state.invented_types_of_guy.borrow()[idx - builtin_count]
            .1
            .clone()
    }
}

fn roll_attribute_contest(attr1: u8, attr2: u8) -> (bool, u32, u32) {
    let mut rng = rand::thread_rng();

    loop {
        let roll1 = rng.gen_range(1..=DICE_SIDES) + attr1 as u32;
        let roll2 = rng.gen_range(1..=DICE_SIDES) + attr2 as u32;

        if roll1 != roll2 {
            return (roll1 > roll2, roll1, roll2);
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum ContestType {
    Strength,
    Agility,
    Charisma,
}

const DICE_SIDES: u32 = 20;

fn fight_round(guy1: &Guy, guy2: &Guy, round: u8) -> bool {
    let mut rng = rand::thread_rng();

    // Randomly select which attribute to contest
    let contest_type = rng.gen_range(0..3);
    let (attr1, attr2, contest_type) = match contest_type {
        0 => (
            guy1.guy_type.strength,
            guy2.guy_type.strength,
            ContestType::Strength,
        ),
        1 => (
            guy1.guy_type.agility,
            guy2.guy_type.agility,
            ContestType::Agility,
        ),
        _ => (
            guy1.guy_type.charisma,
            guy2.guy_type.charisma,
            ContestType::Charisma,
        ),
    };

    let (guy1_wins, roll1, roll2) = roll_attribute_contest(attr1, attr2);
    visualization::print_fight_round(round, guy1, guy2, contest_type, attr1, attr2, roll1, roll2);
    guy1_wins
}

fn fight(state: &GameState) {
    // Generate two random fighters
    let guy_type1 = select_random_guy_type(state);
    let guy_type2 = select_random_guy_type(state);

    let guy1 = Guy::new(names::generate_name(), &guy_type1);
    let guy2 = Guy::new(names::generate_name(), &guy_type2);

    let mut guy1_wins = 0;
    let mut guy2_wins = 0;

    visualization::print_fight_introduction(&guy1, &guy2);

    for round in 1..=3 {
        if fight_round(&guy1, &guy2, round) {
            guy1_wins += 1;
        } else {
            guy2_wins += 1;
        }

        if guy1_wins == 2 {
            visualization::print_winner(&guy1.name);
            return;
        } else if guy2_wins == 2 {
            visualization::print_winner(&guy2.name);
            return;
        }
    }
}

fn main_loop(state: GameState) -> rustyline::Result<()> {
    visualization::print_header();
    visualization::print_menu();

    let mut rl = DefaultEditor::new()?;
    loop {
        match rl.readline("guy> ") {
            Ok(line) => {
                let command = line.trim().to_lowercase();
                if command.is_empty() {
                    continue; // Skip empty lines
                }
                rl.add_history_entry(&line)?;

                match command.as_str() {
                    "quit" => break,
                    "plugins" => visualization::print_plugins_table(&state),
                    "types" => visualization::print_guy_types(&state),
                    "fight" => fight(&state),
                    "help" => visualization::print_menu(),
                    _ => println!("Unknown command: {}", command),
                }
            }
            Err(ReadlineError::Interrupted) | Err(ReadlineError::Eof) => {
                break;
            }
            Err(err) => {
                eprintln!("Error reading line: {:?}", err);
            }
        }
    }
    Ok(())
}

pub fn run_game(plugins_dir: &Path) -> wasmtime::Result<()> {
    let mut state = GameState::new();
    load_plugins(&mut state, plugins_dir)?;

    if let Err(e) = main_loop(state) {
        return Err(wasmtime::Error::msg(format!("Error in main loop: {:?}", e)));
    }
    Ok(())
}
